package main

import (
	"fmt"
	"math/rand"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/lucas-clemente/quic-go"
	flowteledbus "github.com/netsec-ethz/scion-apps/_examples/flowtele/dbus"
	"github.com/netsec-ethz/scion-apps/_examples/flowtele/utils"
	"github.com/scionproto/scion/go/lib/log"
	"gopkg.in/alecthomas/kingpin.v2"
)

const (
	errorNoError quic.ApplicationErrorCode = 0x100
)

var (
	exportIDs           = kingpin.Flag("export", "Searches for QUIC sockets and exports IDs to this file.").Default("").String()
	remoteIpFlag        = kingpin.Flag("ip", "IP address to connect to").Default("127.0.0.1").String()
	remotePortFlag      = kingpin.Flag("port", "Port number to connect to").Default("51000").Int()
	disableApplyControl = kingpin.Flag("disable-apply", "Ignores calls to ApplyControl").Default("false").Bool()
	testingMode         = kingpin.Flag("testing", "Sends dummy signals to athena.").Default("false").Bool()
	fShaperID           = kingpin.Flag("id", "ID to append to the DBUS service name.").Default("-1").Int()
)

var (
	loggerWait sync.WaitGroup
)

const (
	Bit  = 1
	KBit = 1000 * Bit
	MBit = 1000 * KBit
	GBit = 1000 * MBit

	Byte  = 8 * Bit
	KByte = 1000 * Byte
	MByte = 1000 * KByte
)

func init() {
	utils.SetupLogger()
	kingpin.Parse()
}

func main() {
	errChannel := make(chan error)
	closeChannel := make(chan struct{})

	if *exportIDs != "" {
		err := dbusIDExport(*exportIDs)
		if err != nil {
			fmt.Println(err)
			os.Exit(-1)
		}
	}

	if *testingMode {
		log.Info("Starting FShaper in testing mode...\n")
		go func(cc chan struct{}, ec chan error) {
			defer log.HandlePanic()
			invokeTestingShaper(cc, ec)
		}(closeChannel, errChannel)
	} else {
		log.Info("Starting FShaper...\n")
		go func(cc chan struct{}, ec chan error) {
			defer log.HandlePanic()
			invokeFshaper(cc, ec)
		}(closeChannel, errChannel)
	}

	select {
	case err := <-errChannel:
		log.Error(fmt.Sprintf("Error encountered (%s), exiting socket\n", err))
		log.Info("Waiting for data loggers to exit")
		loggerWait.Wait()
		log.Info("Data loggers exited. Returning and exiting.")
		return
	case <-closeChannel:
		log.Info("Exiting without errors")
	}
}

func setupDbus() (*flowteledbus.FshaperDbus, error) {
	remoteAddr := net.UDPAddr{IP: net.ParseIP(*remoteIpFlag), Port: *remotePortFlag}
	peerString := utils.CleanStringForFS(remoteAddr.String())
	fdbus := flowteledbus.NewFshaperDbus(peerString, *disableApplyControl, *fShaperID)

	// if a min interval for the fshaper is specified, make sure to accumulate acked bytes that would otherwise not be registered by athena
	// fdbus.SetMinIntervalForAllSignals(5 * time.Millisecond)

	// dbus setup
	if err := fdbus.OpenSessionBus(); err != nil {
		return nil, err
	}

	// register method and listeners
	if err := fdbus.Register(); err != nil {
		return nil, err
	}

	return fdbus, nil
}

func invokeTestingShaper(closeChannel chan struct{}, errChannel chan error) {
	fdbus, err := setupDbus()
	if err != nil {
		errChannel <- err
		return
	}

	quicIDs := []string{"abc1", "abc2", "abc3"}

	signalCreators := []func() flowteledbus.DbusSignal{}
	for _, id := range quicIDs {
		signalCreators = append(signalCreators, func() flowteledbus.DbusSignal {
			return flowteledbus.CreateQuicDbusSignalCwnd(id, time.Now(), uint32(rand.Int()), rand.Int31(), uint32(rand.Int31()))
		})
		signalCreators = append(signalCreators, func() flowteledbus.DbusSignal {
			return flowteledbus.CreateQuicDbusSignalRtt(id, time.Now(), uint32(rand.Int()))
		})

		signalCreators = append(signalCreators, func() flowteledbus.DbusSignal {
			return flowteledbus.CreateQuicDbusSignalLost(id, time.Now(), uint64(rand.Int63()))
		})
	}

	for _, signalCreator := range signalCreators {
		go func(creator func() flowteledbus.DbusSignal) {
			defer log.HandlePanic()
		loop:
			for {
				select {
				case <-closeChannel:
					break loop
				default:
					signal := creator()
					if fdbus.ShouldSendSignal(signal) {
						if err := fdbus.Send(signal); err != nil {
							errChannel <- err
							return
						}
					}
					time.Sleep(10 * time.Millisecond)
				}
			}
		}(signalCreator)
	}
}

func invokeFshaper(closeChannel chan struct{}, errChannel chan error) {
	fdbus, err := setupDbus()
	if err != nil {
		errChannel <- err
		return
	}

	// listen for feedback from QUIC instances and forward to athena
	go func() {
		defer log.HandlePanic()
		for v := range fdbus.SignalListener {
			if fdbus.Conn.Names()[0] == v.Sender {
				//fdbus.Log("ignore signal %s generated by socket", v.Name)
				continue
			} else if strings.HasPrefix(v.Name, flowteledbus.SERVICE_NAME) {
				continue
			} else {
				//fdbus.Log("forwarding signal %s ... %s", v.Name, v.Sender)
				signal := flowteledbus.CreateFshaperDbusSignal(v)
				if fdbus.ShouldSendSignal(signal) {
					if err := fdbus.Send(signal); err != nil {
						errChannel <- err
						return
					}
				}
			}
		}
	}()

	// don't close the closeChannel to keep running forever
	// fdbus.Close()
	// close(closeChannel)
}
