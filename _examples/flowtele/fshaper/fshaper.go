package main

import (
	"fmt"
	"github.com/lucas-clemente/quic-go"
	flowteledbus "github.com/netsec-ethz/scion-apps/_examples/flowtele/dbus"
	"github.com/netsec-ethz/scion-apps/_examples/flowtele/utils"
	"github.com/scionproto/scion/go/lib/log"
	"gopkg.in/alecthomas/kingpin.v2"
	"net"
	"sync"
)

const (
	errorNoError quic.ApplicationErrorCode = 0x100
)

var (
	remoteIpFlag   = kingpin.Flag("ip", "IP address to connect to").Default("127.0.0.1").String()
	remotePortFlag = kingpin.Flag("port", "Port number to connect to").Default("51000").Int()
	nConnections   = kingpin.Flag("num", "Number of QUIC connections").Default("2").Int()
)

var (
	loggerWait sync.WaitGroup
)

const (
	Bit  = 1
	KBit = 1000 * Bit
	MBit = 1000 * KBit
	GBit = 1000 * MBit

	Byte  = 8 * Bit
	KByte = 1000 * Byte
	MByte = 1000 * KByte
)

func init() {
	utils.SetupLogger()
	kingpin.Parse()
}

func main() {
	errChannel := make(chan error)
	closeChannel := make(chan struct{})

	log.Info("Starting FShaper...\n")
	go func(cc chan struct{}, ec chan error) {
		defer log.HandlePanic()
		invokeFshaper(cc, ec)
	}(closeChannel, errChannel)

	select {
	case err := <-errChannel:
		log.Error(fmt.Sprintf("Error encountered (%s), exiting socket\n", err))
		log.Info("Waiting for data loggers to exit")
		loggerWait.Wait()
		log.Info("Data loggers exited. Returning and exiting.")
		return
	case <-closeChannel:
		log.Info("Exiting without errors")
	}
}

func invokeFshaper(closeChannel chan struct{}, errChannel chan error) {
	remoteAddr := net.UDPAddr{IP: net.ParseIP(*remoteIpFlag), Port: *remotePortFlag}
	peerString := utils.CleanStringForFS(remoteAddr.String())
	fdbus := flowteledbus.NewFshaperDbus(*nConnections, peerString)

	// if a min interval for the fshaper is specified, make sure to accumulate acked bytes that would otherwise not be registered by athena
	// fdbus.SetMinIntervalForAllSignals(5 * time.Millisecond)

	// dbus setup
	if err := fdbus.OpenSessionBus(); err != nil {
		errChannel <- err
		return
	}

	// register method and listeners
	if err := fdbus.Register(); err != nil {
		errChannel <- err
		return
	}

	// listen for feedback from QUIC instances and forward to athena
	go func() {
		defer log.HandlePanic()
		for v := range fdbus.SignalListener {
			if fdbus.Conn.Names()[0] == v.Sender {
				fdbus.Log("ignore signal %s generated by socket", v.Name)
			} else {
				fdbus.Log("forwarding signal %s ...", v.Name)
				signal := flowteledbus.CreateFshaperDbusSignal(v)
				if fdbus.ShouldSendSignal(signal) {
					if err := fdbus.Send(signal); err != nil {
						errChannel <- err
						return
					}
				}
			}
		}
	}()

	// don't close the closeChannel to keep running forever
	// fdbus.Close()
	// close(closeChannel)
}
